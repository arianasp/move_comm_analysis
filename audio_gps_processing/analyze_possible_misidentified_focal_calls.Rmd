---
title: "Analsis of possibly misidentified focal calls"
author: "Ariana Strandburg-Peshkin"
date: "11/10/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Explanation

This script explores the agreement of two labelers on whether calls both identified as focal on two recordings are the same/different and on who the focal caller was. For now, it uses the output from identify_possible_misidentified_focal_calls.R which was run independently by both Vlad (labeler 1) and Baptiste (labeler 2) to visually inspect and hear calls that were identified on two collar recordings as being "focal" and overlapped in time (see identify_possible_misidentified_focal_calls.R for further info). Here we will take a look at the output to assess the level of agreement between the two labelers, as well as how many "matches" were found and how these things are distributed across call types.

## Setting up paths

```{r}
#Directories and input files
setwd('~/Dropbox/code_ari/move_comm_analysis/audio_gps_processing/')

#Files labeled by two independent labelers (in this case Vlad and Baptiste)
match.file1 <- '~/Dropbox/meerkats/meerkats_shared/focal_nonfocal_validation/matches_2019_vlad.RData'
match.file2 <- '~/Dropbox/meerkats/meerkats_shared/focal_nonfocal_validation/matches_2019_baptiste.RData'

```

## Libraries and functions

```{r}
#Libraries
library(fields)
library(viridis)
library(knitr)

#FUNCTIONS
#Function: compute agreement, return as confusion matrix
#Takes in two vecotrs, labels1 and labels2, which contain character strings with 'y' and 'n' depending on whether calls were thought to be the same or not
#Compute and return a confusion matrix with labels1 as row and labels2 as columns, yes as first row/col and no as second row/col
compute.agreement <- function(labels1, labels2, labs = c('u','y','n'), output_plot = T, plot_label = ''){
  
  #first simplify labels to simple y, n, and u (note here the order is important  because 'u' can also be used as part of a 'y' label!)
  simple1 <- simple2 <- rep(NA, length(labels1))
  for(i in labs){
    simple1[grepl(i, labels1)] <- i
    simple2[grepl(i, labels2)] <- i
  }
  
  #construct the agreement matrix (like a confusion matrix)
  agree.mat <- matrix(NA, nrow=length(labs), ncol=length(labs))
  for(i in 1:length(labs)){
    for(j in 1:length(labs)){
      agree.mat[i,j] <- sum(simple1 == labs[i] & simple2 == labs[j])
    }
  }
  
  if(output_plot){
    image.plot(agree.mat, x = 1:length(labs), y = 1:length(labs), ylab = 'Baptiste label', xlab = 'Vlad label', xaxt='n',yaxt='n', col = viridis(256))
    for(i in 1:length(labs)){
      axis(1, at = 1:length(labs), labels = labs)
      axis(2, at = 1:length(labs), labels = labs)
      for(j in 1:length(labs)){
        text(i,j,agree.mat[i,j])
      }
    }
    
    if(plot_label != ''){
      agreement <- round((agree.mat[2,2] + agree.mat[3,3]) / sum(agree.mat[2:3,2:3]) * 100, digits = 1)
      agreement_yeses <- round(2* agree.mat[2,2] / (2* agree.mat[2,2] + agree.mat[2,3] + agree.mat[3,2]) * 100, digits = 1)
      unknowns <- round((sum(agree.mat[1,]) + sum(agree.mat[,1])) / sum(agree.mat) * 100, digits = 1)
      title(main = paste(plot_label, '\n', 'Agreement = ', agreement, '% (total) / ', agreement_yeses, 
                         '% (among yeses) w/ ', unknowns, '% unknown', sep=''))
    }
  }
  
  return(agree.mat)
}
```

## Load data

Note that due to some slight differences in which version of the call labels were used, a few calls are not the same between the labels generated by Vlad and those later generated by Baptiste. In more detail, there were 2942 matches that both labelers looked at, 60 unique to labeler 1 (vlad), and 61 unique to labeler 2 (bapt). We could explore this in more detail later if needed. This also meant that I had to create a new unique identifier for the matches, because the unique identifiers from Baptiste's and Vlad's files did not match. I constructed the 'match.id' from the two file names, the two recording start times, and the two durations. The following analysis only looks at the matches looked at by both Baptiste and Vlad.

```{r}
#LOAD DATA

#load data from match file 1 (in this case vlad), store matches data frame in matches1
load(match.file1)

#due to slight differences in the call lists for the two match files, need a new way of matching based on file.a, file.b, t0.rec.a, t0.rec.b, dur.a, dur.b. create a column match.id for this
matches$match.id <- paste(matches$file.a, matches$file.b, matches$t0.rec.a, matches$t0.rec.b, matches$dur.a, matches$dur.b, sep='|')
matches1 <- matches[idxs,] #get only the ones that were actually looked at by the labeler
calls1 <- calls

#load data from match file 2 (in this case baptiste), store matches data frame in matches.bapt
load(match.file2)
#due to slight differences in the call lists for the two match files, need a new way of matching based on file.a, file.b, t0.rec.a, t0.rec.b, dur.a, dur.b. create a column match.id for this
matches$match.id <- paste(matches$file.a, matches$file.b, matches$t0.rec.a, matches$t0.rec.b, matches$dur.a, matches$dur.b, sep='|')
matches2 <- matches[idxs,] #get only the ones that were actually looked at by the labeler
calls2 <- calls

#remove the 'matches' object to avoid any confusion
rm('matches')
```

## Create comparison table

Now let's create a table called compare.labels which will hold the match.id as well as the labels given by each labeler and the call types (type.a and type.b) of the two potentially-matching calls.

```{r}
#CREATE COMPARISON TABLE TO COMPARE LABELS OF THE TWO LABELERS

#first get the matches that both labelers looked at (due to small differences in the files, there are a few differences in which matches were looked at)
#in more detail, there were 2942 matches that both labelers looked at, 60 unique to labeler 1 (vlad), and 61 unique to labeler 2 (bapt)
matches.to.compare <- intersect(matches1$match.id, matches2$match.id)

#create a data frame that gives the match id and the manual.check.result of both labelers
labeler1 <- matches1[match(matches.to.compare, matches1$match.id),]
labeler2 <- matches2[match(matches.to.compare, matches2$match.id),]
compare.labels <- data.frame(match.id=matches.to.compare, label1 = labeler1$manual.check.result, label2 = labeler2$manual.check.result, type.a = labeler1$type.a, type.b = labeler1$type.b, dist = labeler1$dist.apart, dt = labeler1$dt, dur.a = labeler1$dur.a, dur.b = labeler1$dur.b, stringsAsFactors = F)
```

## Some basic info
First, let's get some info on how many calls of each type we have in our 'matched calls' dataset. Here is a table of the call types, sorted by how common they are (note becuase this uses both sides of the match, the numbers are essentially duplicated).

```{r} 
kable(sort(table(c(compare.labels$type.a, compare.labels$type.b)), decreasing = TRUE))
```

## Agreement 

Let's look at the overall level of agreement between Baptiste and Vlad on whether two calls were the same or not. We'll use an "agreement matrix" to quantify this. Rows represent Baptiste's label and columns given Vlad's label. The possible labels are unknown, yes, no, and these are row/column 1, 2, and 3 respectively.

```{r}
#CALCULATE LEVEL OF AGREEMENT ON WHETHER CALLS ARE THE SAME OR DIFFERENT

#first, what is the level of agreement on whether they are same call or not
agreement.all <- compute.agreement(compare.labels$label1, compare.labels$label2, plot_label = 'All calls')

#Result: Baptiste and Vlad agree on whether two calls are the same 75% of the time

#let's break it down by call type
idxs.cc <- which(compare.labels$type.a=='cc' & compare.labels$type.b == 'cc')
agreement.cc <- compute.agreement(compare.labels$label1[idxs.cc], compare.labels$label2[idxs.cc], plot_label = 'CCs only')
print(agreement.cc)

idxs.sn <- which(compare.labels$type.a=='s' & compare.labels$type.b == 's')
agreement.sn <- compute.agreement(compare.labels$label1[idxs.sn], compare.labels$label2[idxs.sn], plot_label = 'SNs only')

idxs.agg <- which(compare.labels$type.a=='agg' & compare.labels$type.b == 'agg')
agreement.agg <- compute.agreement(compare.labels$label1[idxs.agg], compare.labels$label2[idxs.agg], plot_label = 'AGGs only')

idxs.chat <- which(compare.labels$type.a=='chat' & compare.labels$type.b == 'chat')
agreement.chat <- compute.agreement(compare.labels$label1[idxs.chat], compare.labels$label2[idxs.chat], plot_label = 'CHATs only')

idxs.al <- which(compare.labels$type.a=='al' & compare.labels$type.b == 'al')
agreement.al <- compute.agreement(compare.labels$label1[idxs.al], compare.labels$label2[idxs.al], plot_label = 'ALs only')

idxs.rest <- seq(1,nrow(compare.labels))[-c(idxs.cc,idxs.sn, idxs.agg, idxs.al, idxs.chat)]
agreement.rest <- compute.agreement(compare.labels$label1[idxs.rest], compare.labels$label2[idxs.rest], plot_label = 'Rest of calls')

idxs.any.cc <- union(grep('cc',compare.labels$type.a), grep('cc', compare.labels$type.b))
agreement.any.cc <- compute.agreement(compare.labels$label1[idxs.any.cc], compare.labels$label2[idxs.any.cc], plot_label = 'Either label contains cc')
```

## Agreement about who the focal is
Now let's look at only the matches where both labelers agreed that the call was the same (i.e. answered 'yes'). Did they agree on who the caller was (individual 1 or 2)? First, let's just see how many calls we are talking about, and what calls they are. 

```{r}
#First get matches where both labelers agree it's a match
yesyes.idxs <- which(compare.labels$label1 %in% c('y_1','y_2') & compare.labels$label2 %in% c('y_1','y_2'))
compare.yeses <- compare.labels[yesyes.idxs,]
kable(sort(table(c(compare.yeses$type.a, compare.yeses$type.b)), decreasing = TRUE))
```

Now let's look at the agreement in the same way as before. We'll ignore a few unknowns and mistypings in Baptiste's labels (there were only a couple of them).

```{r}
agree.foc <- compute.agreement(compare.yeses$label1, compare.yeses$label2, labs = c('1','2'))
```

The two labelers agree about the focal individual `r round(sum(diag(agree.foc)) / sum(agree.foc) * 100, digits=1) ` % of the time

## Agreement on focal by call type

```{r}
cc.idxs <- which(grep('cc',compare.yeses$type.a) | grep('cc',compare.yeses$type.b))
agree.foc.cc <- compute.agreement(compare.yeses$label1[cc.idxs], compare.yeses$label2[cc.idxs], labs = c('1','2'))

```

When it comes to close calls in particular (broadly defined), the labelers agree `r round(sum(diag(agree.foc.cc)) / sum(agree.foc.cc) * 100, digits=1) ` % of the time.

## How far apart (in time) are the calls labeled as the same call?

As a check of both our accuracy in synching, and whether the calls labeled as "the same" are likely to actually be the same, let's have a look at how far apart the calls meant to be "the same" are in time. Here is a histogram of the time differences (from the synched GPS times) between calls that have been identified as "the same"e

```{r}
hist(compare.yeses$dt*1000, breaks = seq(0,300,10), xlab = 'Time difference (msec)', ylab = 'Frequency', main = 'Calls identified as the same')
```

The onsets for the vast majority of calls are less then 50 ms apart. Very promising! For comparison, here is the histogram for calls where both labelers agreed they were NOT the same.

```{r}

compare.nos <- compare.labels[which(compare.labels$label1=='n' & compare.labels$label2 == 'n'),]
hist(compare.nos$dt*1000, breaks = seq(0,300,10), xlab = 'Time difference (msec)', ylab = 'Frequency', main = 'Calls identified as different')

```

We can also get a sense of how accurate our labelers are in measuring the duration of calls (though this will likely be an underestimate because calls that actually originate from a meerkat who is not wearing the collar might be harder to measure accurately). Here is a histogram of the differences in estiamted duration (in msec) from calls that were on two recordings and identified as the same call. I've plotted them vs. the average duration between the two labeled calls, since probably this also plays a role.

```{r}

dur.diffs <- abs(compare.yeses$dur.a - compare.yeses$dur.b)
dur.avgs <- (compare.yeses$dur.a + compare.yeses$dur.b) / 2
plot(dur.avgs*1000, dur.diffs*1000, pch = 19, cex = 0.3, xlab = 'Call duration (msec) - average btwn labelers', ylab = 'Difference in cal duration btwn labelers (msec)', main = '', xlim = c(10, max(dur.avgs*1000)), ylim = c(0, max(dur.diffs*1000)), log='x' )

```

Looks like we are broadly accurate within about 20 msec, most of the time. As expected, we are more accurate on shorter calls. 

## Distance apart

If we are picking up something real, we'd expect that the calls identified as the same should come from meerkats that are nearby to one another. Is this true? Let's look at the distribution of distance apart of the two meerkats for calls identified as the same. 
```{r}
yes_dist_hist = hist(compare.yeses$dist, breaks = seq(0,20,1), xlab = 'Distance apart (m)', ylab = 'Frequency', main = 'Distance apart between meerkats when calls from one misidentified as focal')
```

We'll also compare to the distances of the ones where calls were not identified as the same.

```{r}
no_dist_hist = hist(compare.nos$dist, breaks = seq(0,20,1), xlab = 'Distance apart (m)', ylab = 'Frequency', main = 'Distance apart between meerkats when calls are close in time but not identified as the same')
```

Looks like the shorter distances are over-represented in the first plot (where calls were the same). Makes sense. Let's see how much the shorter distances are over-represented there.

```{r}
#normalize
yes_probs = yes_dist_hist$counts / sum(yes_dist_hist$counts)
no_probs = no_dist_hist$counts / sum(no_dist_hist$counts)

plot(yes_dist_hist$mids, log10(yes_probs / no_probs), xlab = 'Distance (m)', ylab = 'Over-representation (log ratio)', pch = 19, ylim = c(-1,1))
abline(h=0)
```

The misidentified focal calls more often come form meerkats that are less than ~3m apart. These distances are over-represented amongst the instances where the calls are the same. Distances above ~3m are underrepresented, and this underrepresentation increases with distance. This pattern seems about as expected. 