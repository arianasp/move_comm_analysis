---
title: "Analysis of possibly misidentified focal calls"
author: "Ariana Strandburg-Peshkin"
date: "11/10/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
```

## Explanation

This analysis explores the agreement of two labelers on whether calls both identified as focal on two recordings are the same/different and on who the focal caller was. For now, it uses the output from identify_possible_misidentified_focal_calls.R which was run independently by both Vlad (labeler 1) and Baptiste (labeler 2) to visually inspect and hear calls that were identified on two collar recordings as being "focal" and overlapped in time (see identify_possible_misidentified_focal_calls.R for further info). Here we will take a look at the output to assess the level of agreement between the two labelers, as well as how many "matches" were found and how these things are distributed across call types.


```{r}
#Directories and input files
setwd('~/Dropbox/code_ari/move_comm_analysis/audio_gps_processing/')

#Files labeled by two independent labelers (in this case Vlad and Baptiste)
match.file1 <- '~/Dropbox/meerkats/meerkats_shared/focal_nonfocal_validation/matches_2019_vlad.RData'
match.file2 <- '~/Dropbox/meerkats/meerkats_shared/focal_nonfocal_validation/matches_2019_baptiste.RData'

#Libraries
library(fields)
library(viridis)
library(knitr)

#FUNCTIONS
#Function: compute agreement, return as confusion matrix
#Takes in two vecotrs, labels1 and labels2, which contain character strings with 'y' and 'n' depending on whether calls were thought to be the same or not
#Compute and return a confusion matrix with labels1 as row and labels2 as columns, yes as first row/col and no as second row/col
compute.agreement <- function(labels1, labels2, labs = c('u','y','n'), output_plot = T, plot_label = ''){
  
  #first simplify labels to simple y, n, and u (note here the order is important  because 'u' can also be used as part of a 'y' label!)
  simple1 <- simple2 <- rep(NA, length(labels1))
  for(i in labs){
    simple1[grepl(i, labels1)] <- i
    simple2[grepl(i, labels2)] <- i
  }
  
  #construct the agreement matrix (like a confusion matrix)
  agree.mat <- matrix(NA, nrow=length(labs), ncol=length(labs))
  for(i in 1:length(labs)){
    for(j in 1:length(labs)){
      agree.mat[i,j] <- sum(simple1 == labs[i] & simple2 == labs[j])
    }
  }
  
  if(output_plot){
    image.plot(agree.mat, x = 1:length(labs), y = 1:length(labs), ylab = 'Baptiste label', xlab = 'Vlad label', xaxt='n',yaxt='n', col = viridis(256))
    for(i in 1:length(labs)){
      axis(1, at = 1:length(labs), labels = labs)
      axis(2, at = 1:length(labs), labels = labs)
      for(j in 1:length(labs)){
        text(i,j,agree.mat[i,j])
      }
    }
    
    if(plot_label != ''){
      agreement <- round((agree.mat[2,2] + agree.mat[3,3]) / sum(agree.mat[2:3,2:3]) * 100, digits = 1)
      agreement_yeses <- round(2* agree.mat[2,2] / (2* agree.mat[2,2] + agree.mat[2,3] + agree.mat[3,2]) * 100, digits = 1)
      unknowns <- round((sum(agree.mat[1,]) + sum(agree.mat[,1])) / sum(agree.mat) * 100, digits = 1)
      title(main = paste(plot_label, '\n', 'Agreement = ', agreement, '% (total) / ', agreement_yeses, 
                         '% (among yeses) w/ ', unknowns, '% unknown', sep=''))
    }
  }
  
  return(agree.mat)
}
```

## Note about the input data

Note that due to some slight differences in which version of the call labels were used, a few calls are not the same between the labels generated by Vlad and those later generated by Baptiste. In more detail, there were 2942 matches that both labelers looked at, 60 unique to labeler 1 (vlad), and 61 unique to labeler 2 (bapt). We could explore this in more detail later if needed. This also meant that I had to create a new unique identifier for the matches, because the unique identifiers from Baptiste's and Vlad's files did not match. I constructed the 'match.id' from the two file names, the two recording start times, and the two durations. The following analysis only looks at the matches looked at by both Baptiste and Vlad.

```{r}
#LOAD DATA

#load data from match file 1 (in this case vlad), store matches data frame in matches1
load(match.file1)

#due to slight differences in the call lists for the two match files, need a new way of matching based on file.a, file.b, t0.rec.a, t0.rec.b, dur.a, dur.b. create a column match.id for this
matches$match.id <- paste(matches$file.a, matches$file.b, matches$t0.rec.a, matches$t0.rec.b, matches$dur.a, matches$dur.b, sep='|')
matches1 <- matches[idxs,] #get only the ones that were actually looked at by the labeler
calls1 <- calls

#load data from match file 2 (in this case baptiste), store matches data frame in matches.bapt
load(match.file2)
#due to slight differences in the call lists for the two match files, need a new way of matching based on file.a, file.b, t0.rec.a, t0.rec.b, dur.a, dur.b. create a column match.id for this
matches$match.id <- paste(matches$file.a, matches$file.b, matches$t0.rec.a, matches$t0.rec.b, matches$dur.a, matches$dur.b, sep='|')
matches2 <- matches[idxs,] #get only the ones that were actually looked at by the labeler
calls2 <- calls

#remove the 'matches' object to avoid any confusion
rm('matches')

#CREATE COMPARISON TABLE TO COMPARE LABELS OF THE TWO LABELERS

#first get the matches that both labelers looked at (due to small differences in the files, there are a few differences in which matches were looked at)
#in more detail, there were 2942 matches that both labelers looked at, 60 unique to labeler 1 (vlad), and 61 unique to labeler 2 (bapt)
matches.to.compare <- intersect(matches1$match.id, matches2$match.id)

#create a data frame that gives the match id and the manual.check.result of both labelers
labeler1 <- matches1[match(matches.to.compare, matches1$match.id),]
labeler2 <- matches2[match(matches.to.compare, matches2$match.id),]
compare.labels <- data.frame(match.id=matches.to.compare, label1 = labeler1$manual.check.result, label2 = labeler2$manual.check.result, type.a = labeler1$type.a, type.b = labeler1$type.b, dist = labeler1$dist.apart, dt = labeler1$dt, dur.a = labeler1$dur.a, dur.b = labeler1$dur.b, stringsAsFactors = F)
```

## Some basic info
First, let's get some info on how many calls of each type we have in our 'matched calls' dataset. Here is a table of the call types, sorted by how common they are (note becuase this uses both sides of the match, the numbers are essentially duplicated).

```{r} 
kable(sort(table(c(compare.labels$type.a, compare.labels$type.b)), decreasing = TRUE))
```

## Agreement 

Let's look at the overall level of agreement between Baptiste and Vlad on whether two calls were the same or not. We'll use an "agreement matrix" to quantify this. Rows represent Baptiste's label and columns given Vlad's label. The possible labels are unknown, yes, no, and these are row/column 1, 2, and 3 respectively.

```{r}
#CALCULATE LEVEL OF AGREEMENT ON WHETHER CALLS ARE THE SAME OR DIFFERENT

#first, what is the level of agreement on whether they are same call or not
agreement.all <- compute.agreement(compare.labels$label1, compare.labels$label2, plot_label = 'All calls')

#Result: Baptiste and Vlad agree on whether two calls are the same 75% of the time

#let's break it down by call type
idxs.cc <- which(compare.labels$type.a=='cc' & compare.labels$type.b == 'cc')
agreement.cc <- compute.agreement(compare.labels$label1[idxs.cc], compare.labels$label2[idxs.cc], plot_label = 'CCs only')

idxs.sn <- which(compare.labels$type.a=='s' & compare.labels$type.b == 's')
agreement.sn <- compute.agreement(compare.labels$label1[idxs.sn], compare.labels$label2[idxs.sn], plot_label = 'SNs only')

idxs.agg <- which(compare.labels$type.a=='agg' & compare.labels$type.b == 'agg')
agreement.agg <- compute.agreement(compare.labels$label1[idxs.agg], compare.labels$label2[idxs.agg], plot_label = 'AGGs only')

idxs.chat <- which(compare.labels$type.a=='chat' & compare.labels$type.b == 'chat')
agreement.chat <- compute.agreement(compare.labels$label1[idxs.chat], compare.labels$label2[idxs.chat], plot_label = 'CHATs only')

idxs.al <- which(compare.labels$type.a=='al' & compare.labels$type.b == 'al')
agreement.al <- compute.agreement(compare.labels$label1[idxs.al], compare.labels$label2[idxs.al], plot_label = 'ALs only')

idxs.rest <- seq(1,nrow(compare.labels))[-c(idxs.cc,idxs.sn, idxs.agg, idxs.al, idxs.chat)]
agreement.rest <- compute.agreement(compare.labels$label1[idxs.rest], compare.labels$label2[idxs.rest], plot_label = 'Rest of calls')

idxs.any.cc <- union(grep('cc',compare.labels$type.a), grep('cc', compare.labels$type.b))
agreement.any.cc <- compute.agreement(compare.labels$label1[idxs.any.cc], compare.labels$label2[idxs.any.cc], plot_label = 'Either label contains cc')
```

## Agreement about who the focal is
Now let's look at only the matches where both labelers agreed that the call was the same (i.e. answered 'yes'). Did they agree on who the caller was (individual 1 or 2)? First, let's just see how many calls we are talking about, and what calls they are. 

```{r}
#First get matches where both labelers agree it's a match
yesyes.idxs <- which(compare.labels$label1 %in% c('y_1','y_2') & compare.labels$label2 %in% c('y_1','y_2'))
compare.yeses <- compare.labels[yesyes.idxs,]
kable(sort(table(c(compare.yeses$type.a, compare.yeses$type.b)), decreasing = TRUE))
```

Now let's look at the agreement in the same way as before. We'll ignore a few unknowns and mistypings in Baptiste's labels (there were only a couple of them).

```{r}
agree.foc <- compute.agreement(compare.yeses$label1, compare.yeses$label2, labs = c('1','2'))
```

The two labelers agree about the focal individual `r round(sum(diag(agree.foc)) / sum(agree.foc) * 100, digits=1) ` % of the time

## Agreement on focal by call type

```{r}
cc.idxs <- which(grep('cc',compare.yeses$type.a) | grep('cc',compare.yeses$type.b))
agree.foc.cc <- compute.agreement(compare.yeses$label1[cc.idxs], compare.yeses$label2[cc.idxs], labs = c('1','2'))

```

When it comes to close calls in particular (broadly defined), the labelers agree `r round(sum(diag(agree.foc.cc)) / sum(agree.foc.cc) * 100, digits=1) ` % of the time.

## How far apart (in time) are the calls labeled as the same call?

As a check of both our accuracy in synching, and whether the calls labeled as "the same" are likely to actually be the same, let's have a look at how far apart the calls meant to be "the same" are in time. Here is a histogram of the time differences (from the synched GPS times) between calls that have been identified as "the same"e

```{r}
hist(compare.yeses$dt*1000, breaks = seq(0,300,10), xlab = 'Time difference (msec)', ylab = 'Frequency', main = 'Calls identified as the same')
```

The onsets for the vast majority of calls are less then 50 ms apart. Very promising! For comparison, here is the histogram for calls where both labelers agreed they were NOT the same.

```{r}

compare.nos <- compare.labels[which(compare.labels$label1=='n' & compare.labels$label2 == 'n'),]
hist(compare.nos$dt*1000, breaks = seq(0,300,10), xlab = 'Time difference (msec)', ylab = 'Frequency', main = 'Calls identified as different')

```

We can also get a sense of how accurate our labelers are in measuring the duration of calls (though this will likely be an underestimate because calls that actually originate from a meerkat who is not wearing the collar might be harder to measure accurately). Here is a histogram of the differences in estiamted duration (in msec) from calls that were on two recordings and identified as the same call. I've plotted them vs. the average duration between the two labeled calls, since probably this also plays a role.

```{r}

dur.diffs <- abs(compare.yeses$dur.a - compare.yeses$dur.b)
dur.avgs <- (compare.yeses$dur.a + compare.yeses$dur.b) / 2
plot(dur.avgs*1000, dur.diffs*1000, pch = 19, cex = 0.3, xlab = 'Call duration (msec) - average btwn labelers', ylab = 'Difference in cal duration btwn labelers (msec)', main = '', xlim = c(10, max(dur.avgs*1000)), ylim = c(0, max(dur.diffs*1000)), log='x' )

```

Looks like we are broadly accurate within about 20 msec, most of the time. As expected, we are more accurate on shorter calls. 

## Distance apart

If we are picking up something real, we'd expect that the calls identified as the same should come from meerkats that are nearby to one another. Is this true? Let's look at the distribution of distance apart of the two meerkats for calls identified as the same. 
```{r}
yes_dist_hist = hist(compare.yeses$dist, breaks = seq(0,20,1), xlab = 'Distance apart (m)', ylab = 'Frequency', main = 'Distance apart between meerkats when calls from one misidentified as focal')
```

We'll also compare to the distances of the ones where calls were not identified as the same.

```{r}
no_dist_hist = hist(compare.nos$dist, breaks = seq(0,20,1), xlab = 'Distance apart (m)', ylab = 'Frequency', main = 'Distance apart between meerkats when calls are close in time but not identified as the same')
```

Looks like the shorter distances are over-represented in the first plot (where calls were the same). Makes sense. Let's see how much the shorter distances are over-represented there.

```{r}
#normalize
yes_probs = yes_dist_hist$counts / sum(yes_dist_hist$counts)
no_probs = no_dist_hist$counts / sum(no_dist_hist$counts)

plot(yes_dist_hist$mids, log10(yes_probs / no_probs), xlab = 'Distance (m)', ylab = 'Over-representation (log ratio)', pch = 19, ylim = c(-1,1))
abline(h=0)
```

The misidentified focal calls more often come form meerkats that are less than ~3m apart. These distances are over-represented amongst the instances where the calls are the same. Distances above ~3m are underrepresented, and this underrepresentation increases with distance. This pattern seems about as expected. 

## Discrepancy between files used by Vlad and Baptiste

Earlier on, I noted that the match tables used by Vlad and Baptiste were not quite the same. This indicates that a few of the calls must be different between those analyzed by Vlad and those by Baptiste, probably because they were corrected in label files in the meantime. Let's have a closer look at this by comparing the call tables from Baptiste and Vlad.

```{r}
#load the files and get their call tables
load(match.file1)
calls$unique.string <- paste(calls$fileName, calls$t0File, calls$duration, calls$entryName, sep='|')
calls1 <- calls
rm('calls')

load(match.file2)
calls$unique.string <- paste(calls$fileName, calls$t0File, calls$duration, calls$entryName, sep='|')
calls2 <- calls
rm('calls')
```

First off, let's check if all the calls are unique within a given table. It turns out there are a few duplicates, though interestingly the acoustic measurements are not necessarily the same. Would be worth looking into these. The table of duplicates from Baptiste's file (the latest one) is below.

```{r}
dups1 <- which(duplicated(calls1$unique.string))
dups2 <- which(duplicated(calls2$unique.string))

kable(calls1[dups2,])
```

Now, on to the matter of the calls which are not shared between Baptiste's and Vlad's versions of the call table. Let's first get these.

```{r}

#find the differences between vlad's and baptiste's call lists
only1 <- setdiff(calls1$unique.string, calls2$unique.string)
only2 <- setdiff(calls2$unique.string, calls1$unique.string)

calls.only1 <- calls1[match(only1,calls1$unique.string),]
calls.only2 <- calls2[match(only2,calls2$unique.string),]

#which files are included?
files.only1 <- unique(calls.only1$fileName)
files.only2 <- unique(calls.only2$fileName)
```

Turns out the differences stem from the following files:

```{r}
print(files.only1)
print(files.only2)
```

This means that any results from intersections with those files need to be redone by the first labeler (Vlad)! But the rest should be fine. 

The match.ids in Baptiste's matches that need to be also labeled by Vlad are the following:

```{r}
matches.only2 <- setdiff(matches2$match.id, matches1$match.id)
matches.only1 <- setdiff(matches1$match.id, matches2$match.id)

kable(matches.only2)
```

They are all ones associated with those 3 files that were resynched EXCEPT the first 2 (HM_VHMF010_SOUNDFOC_20190713_BA.WAV|HM_VHMM017_RSTB_R23_20190708-20190720_file_7_(2019_07_13-11_44_59)_135944_LL_VD.wav|01:59:09.237|02:05:43.127|0.177|0.093
HM_VCVM001_SOUNDFOC_20190718_BA.WAV|HM_VHMM016_LTTB_R29_20190707-20190719_file_12_(2019_07_18-11_44_59)_185944_HB_VD.wav|01:51:54.110|01:55:57.957|0.207|0.134)

I am still quite mystified by this, since the corresponding calls are actually present in both calls tables from the two files, so I don't see why they were matched in Baptiste's but not in Vlad's version! But anyway, these 2 should also be labeled by Vlad as well.

## Comparing amplitude to neighboring calls
One way to potentially identify focal vs non-focal calls is to compare the amplitude on the 2 devices. However, is this a reliable way to do things? Let's start by looking at all the calls in a given file of a given type, and computing the amplitude of ones labeled "focal" and "non-focal". Are they distinguishable? Let's use the calls2 table (Baptiste's later one) for this, because it should be more up to date.

The plots below show (for each file) the distribution of RMS (amplitude, high-pass filtered; 100 Hz Butterworth) across the calls labeled as CC's (broadly defined, accessed via grepping for 'cc'). In blue, the calls labeled "focal" and in red, the calls labeled "nonfocal" by the labeler (black = distribution over all calls in that category). Note that data are only included for files with > 10 nonfocal and > 10 focal calls. Numbers of each type are shown as text in the plots. Legend background for focal microphone recordings is gray.

```{r, fig.height = 20, fig.width = 10}
#get all files
all.files <- unique(calls2$fileName)
par(mfrow = c(20,5), mar = c(0,0,0,0))
#pick a particular file as an example
for(i in 1:length(all.files)){
  test.file <- all.files[i]
  
  if(grepl('SOUNDFOC',test.file)){
    bg <- 'gray'
  } else{
    bg <- 'white'
  }
  
  #pick only a certain call type
  call.type <- 'cc'
  
  #get all calls from that file
  calls.in.file <- calls2[which(calls2$fileName == test.file),]
  
  #get calls of that type
  rows <- grep(call.type,calls.in.file$callType)
  calls.in.file.type <- calls.in.file[rows,]
  
  #histograms of focal vs non-focal RMS (from Avisoft, high pass filter Butterworth 0.1 kHz applied in pre-processing) - Vlad has documentation of this process
  foc.rms <- calls.in.file.type$rms[which(calls.in.file.type$nonFocal==0 & calls.in.file.type$unsureFocal==0 )]
  nonfoc.rms <- calls.in.file.type$rms[which(calls.in.file.type$nonFocal==1 & calls.in.file.type$unsureFocal==0 )]
  
  min.rms <- min(calls2$rms,na.rm=T)
  max.rms <- max(calls2$rms,na.rm=T)
  
  if(length(foc.rms)>10 & length(nonfoc.rms)>10){
    dens.foc <- density(foc.rms, bw = 2, from = min.rms, to = max.rms, na.rm=T)
    dens.nonfoc <- density(nonfoc.rms, bw = 2, from = min.rms, to = max.rms, na.rm=T)
        dens.all <- density(c(foc.rms, nonfoc.rms), bw = 2, from = min.rms, to = max.rms, na.rm=T)
    ymax <- max(dens.foc$y, dens.nonfoc$y)

    plot(dens.foc$x, dens.foc$y, xlim=c(min.rms,max.rms), ylim = c(0,ymax), xlab = 'RMS', ylab = 'Density', main='', col = 'blue', type = 'l', xaxt='n', yaxt = 'n', bg = bg)
    lines(dens.nonfoc$x, dens.nonfoc$y, col = 'red')
    lines(dens.all$x, dens.all$y, col = 'black')
    legend('topright',legend=c(sum(!is.na(foc.rms)), sum(!is.na(nonfoc.rms))), fill = c('blue','red'), cex = 1, bg = bg)
  }
}
```

Overall, this is not looking promising. Clearly, the labelers are not paying attention to absolute amplitude alone when assessing whether to label something as focal or non-focal, or alternatively our measurement of RMS is not reliable. 

One question is whether this could be being confounded by noise. Let's make the same comparison but for calls labeled "noisy" vs those not labeled "noisy". Here, we will show the "noisy" calls as blue and the non-noisy as black.

```{r, fig.height = 20, fig.width = 10}
#get all files
all.files <- unique(calls2$fileName)
par(mfrow = c(20,5), mar = c(0,0,0,0))
#pick a particular file as an example
for(i in 1:length(all.files)){
  test.file <- all.files[i]
  
  #pick only a certain call type
  call.type <- 'cc'
  
  #get all calls from that file
  calls.in.file <- calls2[which(calls2$fileName == test.file),]
  
  #get calls of that type
  rows <- grep(call.type,calls.in.file$callType)
  calls.in.file.type <- calls.in.file[rows,]
  
  #histograms of focal vs non-focal RMS (from Avisoft, high pass filter Butterworth 0.1 kHz applied in pre-processing) - Vlad has documentation of this process
  foc.rms <- calls.in.file.type$rms[which(calls.in.file.type$noisy==1)]
  nonfoc.rms <- calls.in.file.type$rms[which(calls.in.file.type$noisy==0)]
  
  min.rms <- min(calls2$rms,na.rm=T)
  max.rms <- max(calls2$rms,na.rm=T)
  
  if(length(foc.rms)>10 & length(nonfoc.rms)>10){
    dens.foc <- density(foc.rms, bw = 2, from = min.rms, to = max.rms, na.rm=T)
    dens.nonfoc <- density(nonfoc.rms, bw = 2, from = min.rms, to = max.rms, na.rm=T)
    ymax <- max(dens.foc$y, dens.nonfoc$y)
    
    plot(dens.foc$x, dens.foc$y, xlim=c(min.rms,max.rms), ylim = c(0,ymax), xlab = 'RMS', ylab = 'Density', main='', col = 'blue', type = 'l', xaxt='n', yaxt = 'n')
    lines(dens.nonfoc$x, dens.nonfoc$y, col = 'black')
  }
}
```

The measured amplitude also does not seem to relate to the "noisy" label. 

What about for the calls labeled as focal or nonfocal by Baptiste and Vlad, during the focal/non-focal comparison stage? Did Vlad and Baptiste label these based on their overall amplitude, as measured by our RMS measure? 

Since there was high agreement, let's just use Baptiste's labels (matches2) for this.

```{r}

matches.use <- matches2
calls.use <- calls2

#get RMS for call a and call b
matches.use$call.a.id <- paste(matches.use$file.a, matches.use$t0.rec.a, matches.use$dur.a, matches.use$type.a, sep = '|')
matches.use$call.b.id <- paste(matches.use$file.b, matches.use$t0.rec.b, matches.use$dur.b, matches.use$type.b, sep = '|')
calls.use$call.id <- paste(calls.use$fileName, calls.use$t0File, calls.use$duration, calls.use$entryName, sep = '|')
matches.use$RMS.a <- calls.use$rms[match(matches.use$call.a.id, calls.use$call.id)]
matches.use$RMS.b <- calls.use$rms[match(matches.use$call.b.id, calls.use$call.id)]

#get rows marked as 'individual 1 is the focal'
foc1.rows <- which(matches.use$manual.check.result=='y_1')
foc2.rows <- which(matches.use$manual.check.result=='y_2')

#get the amplitude difference between the focal call and the nonfocal call (as determined by the labeler)
rms.diff.foc <- c(matches.use$RMS.a[foc1.rows] - matches.use$RMS.b[foc1.rows], matches.use$RMS.b[foc2.rows] - matches.use$RMS.a[foc2.rows])

#plot a histogram of these differences
dens <- density(rms.diff.foc, bw = 2, na.rm=T)
plot(dens$x, dens$y, col = 'red', type = 'l', lwd = 2, xlab = 'RMS focal - RMS nonfocal', ylab = 'denstiy')
abline(v=0)

```

There seems to be some signal there, with the one labeled as focal more likely to be the one with the larger amplitude. However, about `r round(mean(rms.diff.foc<0,na.rm=T)*100)`% of the time the quieter call was labeled as focal. 
