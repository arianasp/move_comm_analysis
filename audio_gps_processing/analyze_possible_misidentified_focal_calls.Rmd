---
title: "Analsis of possibly misidentified focal calls"
author: "Ariana Strandburg-Peshkin"
date: "11/10/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Explanation

This script explores the agreement of two labelers on whether calls both identified as focal on two recordings are the same/different and on who the focal caller was. For now, it uses the output from identify_possible_misidentified_focal_calls.R which was run independently by both Vlad (labeler 1) and Baptiste (labeler 2) to visually inspect and hear calls that were identified on two collar recordings as being "focal" and overlapped in time (see identify_possible_misidentified_focal_calls.R for further info). Here we will take a look at the output to assess the level of agreement between the two labelers, as well as how many "matches" were found and how these things are distributed across call types.

## Setting up paths

```{r}
#Directories and input files
setwd('~/Dropbox/code_ari/move_comm_analysis/audio_gps_processing/')

#Files labeled by two independent labelers (in this case Vlad and Baptiste)
match.file1 <- '~/Dropbox/meerkats/meerkats_shared/focal_nonfocal_validation/matches_2019_vlad.RData'
match.file2 <- '~/Dropbox/meerkats/meerkats_shared/focal_nonfocal_validation/matches_2019_baptiste.RData'

```

## Libraries and functions

```{r}
#Libraries
library(fields)
library(viridis)
library(knitr)

#FUNCTIONS
#Function: compute agreement, return as confusion matrix
#Takes in two vecotrs, labels1 and labels2, which contain character strings with 'y' and 'n' depending on whether calls were thought to be the same or not
#Compute and return a confusion matrix with labels1 as row and labels2 as columns, yes as first row/col and no as second row/col
compute.agreement <- function(labels1, labels2, labs = c('u','y','n'), output_plot = T, plot_label = ''){
  
  #first simplify labels to simple y, n, and u (note here the order is important  because 'u' can also be used as part of a 'y' label!)
  simple1 <- simple2 <- rep(NA, length(labels1))
  for(i in labs){
    simple1[grepl(i, labels1)] <- i
    simple2[grepl(i, labels2)] <- i
  }
  
  #construct the agreement matrix (like a confusion matrix)
  agree.mat <- matrix(NA, nrow=length(labs), ncol=length(labs))
  for(i in 1:length(labs)){
    for(j in 1:length(labs)){
      agree.mat[i,j] <- sum(simple1 == labs[i] & simple2 == labs[j])
    }
  }
  
  if(output_plot){
    image.plot(agree.mat, x = 1:length(labs), y = 1:length(labs), ylab = 'Baptiste label', xlab = 'Vlad label', xaxt='n',yaxt='n', col = viridis(256))
    for(i in 1:length(labs)){
      axis(1, at = 1:length(labs), labels = labs)
      axis(2, at = 1:length(labs), labels = labs)
      for(j in 1:length(labs)){
        text(i,j,agree.mat[i,j])
      }
    }
    
    if(plot_label != ''){
      agreement <- round((agree.mat[2,2] + agree.mat[3,3]) / sum(agree.mat[2:3,2:3]) * 100, digits = 1)
      agreement_yeses <- round(2* agree.mat[2,2] / (2* agree.mat[2,2] + agree.mat[2,3] + agree.mat[3,2]) * 100, digits = 1)
      unknowns <- round((sum(agree.mat[1,]) + sum(agree.mat[,1])) / sum(agree.mat) * 100, digits = 1)
      title(main = paste(plot_label, '\n', 'Agreement = ', agreement, '% (total) / ', agreement_yeses, 
                         '% (among yeses) w/ ', unknowns, '% unknown', sep=''))
    }
  }
  
  return(agree.mat)
}
```

## Load data

Note that due to some slight differences in which version of the call labels were used, a few calls are not the same between the labels generated by Vlad and those later generated by Baptiste. In more detail, there were 2942 matches that both labelers looked at, 60 unique to labeler 1 (vlad), and 61 unique to labeler 2 (bapt). We could explore this in more detail later if needed. This also meant that I had to create a new unique identifier for the matches, because the unique identifiers from Baptiste's and Vlad's files did not match. I constructed the 'match.id' from the two file names, the two recording start times, and the two durations. The following analysis only looks at the matches looked at by both Baptiste and Vlad.

```{r}
#LOAD DATA

#load data from match file 1 (in this case vlad), store matches data frame in matches1
load(match.file1)

#due to slight differences in the call lists for the two match files, need a new way of matching based on file.a, file.b, t0.rec.a, t0.rec.b, dur.a, dur.b. create a column match.id for this
matches$match.id <- paste(matches$file.a, matches$file.b, matches$t0.rec.a, matches$t0.rec.b, matches$dur.a, matches$dur.b, sep='|')
matches1 <- matches[idxs,] #get only the ones that were actually looked at by the labeler
calls1 <- calls

#load data from match file 2 (in this case baptiste), store matches data frame in matches.bapt
load(match.file2)
#due to slight differences in the call lists for the two match files, need a new way of matching based on file.a, file.b, t0.rec.a, t0.rec.b, dur.a, dur.b. create a column match.id for this
matches$match.id <- paste(matches$file.a, matches$file.b, matches$t0.rec.a, matches$t0.rec.b, matches$dur.a, matches$dur.b, sep='|')
matches2 <- matches[idxs,] #get only the ones that were actually looked at by the labeler
calls2 <- calls

#remove the 'matches' object to avoid any confusion
rm('matches')
```

## Create comparison table

Now let's create a table called compare.labels which will hold the match.id as well as the labels given by each labeler and the call types (type.a and type.b) of the two potentially-matching calls.

```{r}
#CREATE COMPARISON TABLE TO COMPARE LABELS OF THE TWO LABELERS

#first get the matches that both labelers looked at (due to small differences in the files, there are a few differences in which matches were looked at)
#in more detail, there were 2942 matches that both labelers looked at, 60 unique to labeler 1 (vlad), and 61 unique to labeler 2 (bapt)
matches.to.compare <- intersect(matches1$match.id, matches2$match.id)

#create a data frame that gives the match id and the manual.check.result of both labelers
labeler1 <- matches1[match(matches.to.compare, matches1$match.id),]
labeler2 <- matches2[match(matches.to.compare, matches2$match.id),]
compare.labels <- data.frame(match.id=matches.to.compare, label1 = labeler1$manual.check.result, label2 = labeler2$manual.check.result, type.a = labeler1$type.a, type.b = labeler1$type.b, stringsAsFactors = F)
```

## Some basic info
First, let's get some info on how many calls of each type we have in our 'matched calls' dataset. Here is a table of the call types, sorted by how common they are (note becuase this uses both sides of the match, the numbers are essentially duplicated).

```{r} 
kable(sort(table(c(compare.labels$type.a, compare.labels$type.b)), decreasing = TRUE))
```

## Agreement 

Let's look at the overall level of agreement between Baptiste and Vlad on whether two calls were the same or not. We'll use an "agreement matrix" to quantify this. Rows represent Baptiste's label and columns given Vlad's label. The possible labels are unknown, yes, no, and these are row/column 1, 2, and 3 respectively.

```{r}
#CALCULATE LEVEL OF AGREEMENT ON WHETHER CALLS ARE THE SAME OR DIFFERENT

#first, what is the level of agreement on whether they are same call or not
agreement.all <- compute.agreement(compare.labels$label1, compare.labels$label2, plot_label = 'All calls')

#Result: Baptiste and Vlad agree on whether two calls are the same 75% of the time

#let's break it down by call type
idxs.cc <- which(compare.labels$type.a=='cc' & compare.labels$type.b == 'cc')
agreement.cc <- compute.agreement(compare.labels$label1[idxs.cc], compare.labels$label2[idxs.cc], plot_label = 'CCs only')
print(agreement.cc)

idxs.sn <- which(compare.labels$type.a=='s' & compare.labels$type.b == 's')
agreement.sn <- compute.agreement(compare.labels$label1[idxs.sn], compare.labels$label2[idxs.sn], plot_label = 'SNs only')

idxs.agg <- which(compare.labels$type.a=='agg' & compare.labels$type.b == 'agg')
agreement.agg <- compute.agreement(compare.labels$label1[idxs.agg], compare.labels$label2[idxs.agg], plot_label = 'AGGs only')

idxs.chat <- which(compare.labels$type.a=='chat' & compare.labels$type.b == 'chat')
agreement.chat <- compute.agreement(compare.labels$label1[idxs.chat], compare.labels$label2[idxs.chat], plot_label = 'CHATs only')

idxs.al <- which(compare.labels$type.a=='al' & compare.labels$type.b == 'al')
agreement.al <- compute.agreement(compare.labels$label1[idxs.al], compare.labels$label2[idxs.al], plot_label = 'ALs only')

idxs.rest <- seq(1,nrow(compare.labels))[-c(idxs.cc,idxs.sn, idxs.agg, idxs.al, idxs.chat)]
agreement.rest <- compute.agreement(compare.labels$label1[idxs.rest], compare.labels$label2[idxs.rest], plot_label = 'Rest of calls')

idxs.any.cc <- union(grep('cc',compare.labels$type.a), grep('cc', compare.labels$type.b))
agreement.any.cc <- compute.agreement(compare.labels$label1[idxs.any.cc], compare.labels$label2[idxs.any.cc], plot_label = 'Either label contains cc')
```

## Agreement about who the focal is
Now let's look at only the matches where both labelers agreed that the call was the same (i.e. answered 'yes'). Did they agree on who the caller was (individual 1 or 2)? First, let's just see how many calls we are talking about, and what calls they are. 

```{r}
#First get matches where both labelers agree it's a match
yesyes.idxs <- which(compare.labels$label1 %in% c('y_1','y_2') & compare.labels$label2 %in% c('y_1','y_2'))
compare.yeses <- compare.labels[yesyes.idxs,]
kable(sort(table(c(compare.yeses$type.a, compare.yeses$type.b)), decreasing = TRUE))
```

Now let's look at the agreement in the same way as before. We'll ignore a few unknowns and mistypings in Baptiste's labels (there were only a couple of them).

```{r}
agree.foc <- compute.agreement(compare.yeses$label1, compare.yeses$label2, labs = c('1','2'))
```

The two labelers agree about the focal individual `r round(sum(diag(agree.foc)) / sum(agree.foc) * 100, digits=1) ` % of the time

## Agreement on focal by call type

```{r}
cc.idxs <- which(grep('cc',compare.yeses$type.a) | grep('cc',compare.yeses$type.b))
agree.foc.cc <- compute.agreement(compare.yeses$label1[cc.idxs], compare.yeses$label2[cc.idxs], labs = c('1','2'))

```

When it comes to close calls in particular (broadly defined), the labelers agree `r round(sum(diag(agree.foc.cc)) / sum(agree.foc.cc) * 100, digits=1) ` % of the time.